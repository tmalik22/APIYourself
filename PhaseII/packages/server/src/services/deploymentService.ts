import axios from 'axios';
import * as fs from 'fs-extra';
import * as path from 'path';
import archiver from 'archiver';
import { createWriteStream } from 'fs';

// Path to projects.json
const PROJECTS_FILE = path.join(__dirname, '../../projects.json');

// Helper to load projects from disk
function loadProjects() {
  try {
    if (fs.existsSync(PROJECTS_FILE)) {
      return fs.readJsonSync(PROJECTS_FILE);
    }
    return [];
  } catch (err) {
    console.error('Failed to load projects:', err);
    return [];
  }
}

// Helper to save projects to disk
function saveProjects(projects: any[]) {
  try {
    fs.writeJsonSync(PROJECTS_FILE, projects, { spaces: 2 });
  } catch (err) {
    console.error('Failed to save projects:', err);
  }
}

// Initialize projects from disk
let projects: any[] = loadProjects();

interface DeploymentResult {
  success: boolean;
  deploymentUrl?: string;
  deploymentId?: string;
  error?: string;
}

export class DeploymentService {
  private vercelToken: string | undefined;

  constructor() {
    this.vercelToken = process.env.VERCEL_TOKEN;
  }

  async deployToVercel(project: any): Promise<DeploymentResult> {
    if (!this.vercelToken) {
      return {
        success: false,
        error: 'Vercel token not configured. Set VERCEL_TOKEN environment variable.'
      };
    }

    try {
      // Generate actual project files based on the project configuration
      const projectFiles = await this.generateProjectFiles(project);
      
      // Create deployment package
      const zipPath = await this.createDeploymentPackage(project.id, projectFiles);
      
      // Deploy to Vercel using their API
      const deploymentResult = await this.deployToVercelAPI(project, zipPath);
      
      // Clean up temporary files
      await fs.remove(zipPath);
      
      return deploymentResult;
    } catch (error: any) {
      return {
        success: false,
        error: `Deployment failed: ${error.message}`
      };
    }
  }

  public async generateProjectFiles(project: any): Promise<Record<string, string>> {
    const files: Record<string, string> = {};

    // Generate package.json
    files['package.json'] = JSON.stringify({
      name: project.name.toLowerCase().replace(/\s+/g, '-'),
      version: '1.0.0',
      description: project.description,
      main: 'index.js',
      scripts: {
        start: 'node index.js',
        dev: 'node index.js'
      },
      dependencies: {
        express: '^4.18.2',
        cors: '^2.8.5'
      }
    }, null, 2);

    // Generate main server file
    files['index.js'] = this.generateServerCode(project);

    // Generate vercel.json configuration
    files['vercel.json'] = JSON.stringify({
      version: 2,
      builds: [
        {
          src: 'index.js',
          use: '@vercel/node'
        }
      ],
      routes: [
        {
          src: '/(.*)',
          dest: '/index.js'
        }
      ]
    }, null, 2);

    // Generate README
    files['README.md'] = `# ${project.name}\n\n${project.description}\n\nGenerated by APIYourself`;

    return files;
  }

  private generateServerCode(project: any): string {
    const endpoints = project.endpoints || [];
    
    let endpointCode = '';
    endpoints.forEach((endpoint: any) => {
      endpointCode += `
app.${endpoint.method.toLowerCase()}('${endpoint.path}', (req, res) => {
  // ${endpoint.description || `${endpoint.method} ${endpoint.path}`}
  res.json({ 
    message: '${endpoint.name || `${endpoint.method} ${endpoint.path}`}',
    method: '${endpoint.method}',
    path: '${endpoint.path}',
    timestamp: new Date().toISOString()
  });
});
`;
    });

    return `const express = require('express');
const cors = require('cors');

const app = express();
const port = process.env.PORT || 3000;

app.use(cors());
app.use(express.json());

// Health check
app.get('/', (req, res) => {
  res.json({
    name: '${project.name}',
    description: '${project.description}',
    status: 'running',
    timestamp: new Date().toISOString()
  });
});

// Generated endpoints
${endpointCode}

// 404 handler
app.use('*', (req, res) => {
  res.status(404).json({
    error: 'Endpoint not found',
    path: req.originalUrl,
    method: req.method
  });
});

app.listen(port, () => {
  console.log(\`ðŸš€ \${JSON.stringify({
    name: '${project.name}',
    port: port,
    endpoints: ${JSON.stringify(endpoints.map((e: any) => `${e.method} ${e.path}`))},
    status: 'running'
  })}\`);
});

module.exports = app;`;
  }

  private async createDeploymentPackage(projectId: string, files: Record<string, string>): Promise<string> {
    const tempDir = path.join(__dirname, '../../temp', projectId);
    const zipPath = path.join(__dirname, '../../temp', `${projectId}.zip`);

    // Ensure temp directory exists
    await fs.ensureDir(tempDir);
    await fs.ensureDir(path.dirname(zipPath));

    // Write all files to temp directory
    for (const [fileName, content] of Object.entries(files)) {
      const filePath = path.join(tempDir, fileName);
      await fs.writeFile(filePath, content);
    }

    // Create zip archive
    return new Promise((resolve, reject) => {
      const output = createWriteStream(zipPath);
      const archive = archiver('zip', { zlib: { level: 9 } });

      output.on('close', () => resolve(zipPath));
      archive.on('error', reject);

      archive.pipe(output);
      archive.directory(tempDir, false);
      archive.finalize();
    });
  }

  private async deployToVercelAPI(project: any, zipPath: string): Promise<DeploymentResult> {
    try {
      // Read the zip file
      const zipBuffer = await fs.readFile(zipPath);

      // Upload files to Vercel
      const filesResponse = await axios.post('https://api.vercel.com/v2/files', zipBuffer, {
        headers: {
          'Authorization': `Bearer ${this.vercelToken}`,
          'Content-Type': 'application/octet-stream'
        }
      });

      const fileIds = filesResponse.data;

      // Create deployment
      const deploymentResponse = await axios.post('https://api.vercel.com/v13/deployments', {
        name: project.name.toLowerCase().replace(/\s+/g, '-'),
        files: Object.keys(fileIds).map(filename => ({
          file: filename,
          sha: fileIds[filename]
        })),
        projectSettings: {
          framework: 'other'
        }
      }, {
        headers: {
          'Authorization': `Bearer ${this.vercelToken}`,
          'Content-Type': 'application/json'
        }
      });

      const deployment = deploymentResponse.data;

      return {
        success: true,
        deploymentUrl: `https://${deployment.url}`,
        deploymentId: deployment.id
      };

    } catch (error: any) {
      console.error('Vercel deployment error:', error.response?.data || error.message);
      return {
        success: false,
        error: `Vercel deployment failed: ${error.response?.data?.error?.message || error.message}`
      };
    }
  }

  async deployToRailway(project: any): Promise<DeploymentResult> {
    // TODO: Implement Railway deployment
    return {
      success: false,
      error: 'Railway deployment not yet implemented'
    };
  }

  async deployToRender(project: any): Promise<DeploymentResult> {
    // TODO: Implement Render deployment
    return {
      success: false,
      error: 'Render deployment not yet implemented'
    };
  }
}
